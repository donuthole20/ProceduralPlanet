resolution = glm::min(glm::abs((int)resolution), 250);
		glm::vec3 axisA = glm::vec3(localUp->y, localUp->z, localUp->x);
		glm::vec3 axisB = glm::cross(*localUp, axisA);

		std::vector<glm::vec3> positions(resolution * resolution, glm::vec3(0, 0, 0));
		std::vector<unsigned int> indices(((resolution - 1) * (resolution - 1) * 6), 0);

		size_t triIndex = 0;

		for (size_t y = 0; y < resolution; y++)
		{
			for (size_t x = 0; x < resolution; x++)
			{
				size_t i = x + y * resolution;
				glm::vec2 percent = glm::vec2(x, y);
				percent /= (resolution - 1);
				glm::vec3 pointOnUnitCube = *localUp + (percent.x - 0.5f) * 2 * axisA + (percent.y - 0.5f) * 2 * axisB;
				glm::vec3 pointOnUnitSphere = glm::normalize(pointOnUnitCube);
				positions[i] = pointOnUnitSphere;
				//std::cout << pointOnUnitSphere.x << "," << pointOnUnitSphere.y << "," << pointOnUnitSphere.z << std::endl;
				if (x != resolution - 1 && y != resolution - 1)
				{
					indices[triIndex] = i;
					indices[triIndex + 1] = i + resolution + 1;
					indices[triIndex + 2] = i + resolution;

					indices[triIndex + 3] = i;
					indices[triIndex + 4] = i + 1;
					indices[triIndex + 5] = i + resolution + 1;
					triIndex += 6;
				}
			}
		}